<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-面试相关/2024-05-13-00-17-30-redis xiang-guan-mian-shi-ti-gui-zong" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">redis 相关面试题归总 | Z 不殊</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://zbus.top/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="redis 相关面试题归总 | Z 不殊"><meta data-rh="true" name="description" content="img"><meta data-rh="true" property="og:description" content="img"><meta data-rh="true" property="og:image" content="https://img.zbus.top/zbus/blog202403150754487.webp"><meta data-rh="true" name="twitter:image" content="https://img.zbus.top/zbus/blog202403150754487.webp"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://zbus.top/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong"><link data-rh="true" rel="alternate" href="https://zbus.top/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://zbus.top/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://KNKL89273C-dsn.algolia.net" crossorigin="anonymous"><link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141789564-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-S4SD5NXWXF"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-S4SD5NXWXF",{anonymize_ip:!0})</script>


<link rel="search" type="application/opensearchdescription+xml" title="Z 不殊" href="/opensearch.xml">


<script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3fe9ea74bd372ee22bcbf0caaf670701";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>
<link rel="icon" href="/img/logo.png">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#12affa">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Z 不殊 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Z 不殊 Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="Z 不殊 JSON Feed">

<meta name="Z 不殊" content="Z 不殊的个人博客">
<meta name="快跑小火车" content="Z 不殊的个人博客">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/misans@4.0.0/lib/Normal/MiSans-Normal.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/misans@4.0.0/lib/Normal/MiSans-Semibold.min.css"><link rel="stylesheet" href="/assets/css/styles.d849ed05.css">
<script src="/assets/js/runtime~main.db8def2a.js" defer="defer"></script>
<script src="/assets/js/main.1b23ef6c.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/logo.jpg" alt="Z 不殊 Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/logo.jpg" alt="Z 不殊 Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Z 不殊</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">文档</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" href="/blog">博客</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/blog">博客列表</a></li><li><a class="dropdown__link" href="/blog/archive">归档</a></li></ul></div><a class="navbar__item navbar__link" href="/friends">友链</a><a class="navbar__item navbar__link" href="/project">项目</a><a class="navbar__item navbar__link" href="/about">关于我</a></div><div class="navbar__items navbar__items--right"><a href="https://afdian.net/a/zbusTop" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">为爱发电<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/zhoujun134" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/"><img src="/logo.jpg" alt="Z 不殊 Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/logo.jpg" alt="Z 不殊 Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"><b>Z 不殊</b></a><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">介绍</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/刷题笔记">刷题笔记</a><button aria-label="展开侧边栏分类 &#x27;刷题笔记&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/java-基础">Java 基础</a><button aria-label="展开侧边栏分类 &#x27;Java 基础&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/分布式服务">分布式服务</a><button aria-label="展开侧边栏分类 &#x27;分布式服务&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/docusaurus-魔改之路">Docusaurus 魔改之路</a><button aria-label="展开侧边栏分类 &#x27;Docusaurus 魔改之路&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/git-使用手册">git 使用手册</a><button aria-label="展开侧边栏分类 &#x27;git 使用手册&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/flexmark框架">flexmark框架</a><button aria-label="展开侧边栏分类 &#x27;flexmark框架&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/nginx">nginx</a><button aria-label="展开侧边栏分类 &#x27;nginx&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/后端面试相关java">后端面试相关（java）</a><button aria-label="折叠侧边栏分类 &#x27;后端面试相关（java）&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong">redis 相关面试题归总</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/面试相关/zookeeper mian-shi-ti-gui-zong">zookeeper 面试题归总</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/linux">linux</a><button aria-label="展开侧边栏分类 &#x27;linux&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/工具日志">工具日志</a><button aria-label="展开侧边栏分类 &#x27;工具日志&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/前端">前端</a><button aria-label="展开侧边栏分类 &#x27;前端&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/后端面试相关java"><span itemprop="name">后端面试相关（java）</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">redis 相关面试题归总</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>redis 相关面试题归总</h1></header><p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405102245256.jpg" alt="img" class="img_CujE"></div><p></p>
<p>redis 是一个高性能的 key-value 数据库，它是完全开源免费的，而且 redis 是一个 NOSQL 类型数据库，是为了解决高并发、高扩展，大数据存储等一系列的问题而产生的数据库解决方案，是一个非关系型的数据库。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1-redis-集群如何进行故障转移如何保证高可用主从同步的过程-rdb-是什么">1 redis 集群如何进行故障转移？如何保证高可用？主从同步的过程？ Rdb 是什么？<a class="hash-link" aria-label="1 redis 集群如何进行故障转移？如何保证高可用？主从同步的过程？ Rdb 是什么？的直接链接" title="1 redis 集群如何进行故障转移？如何保证高可用？主从同步的过程？ Rdb 是什么？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#1-redis-集群如何进行故障转移如何保证高可用主从同步的过程-rdb-是什么">​</a></h2>
<p>Redis集群的故障转移、高可用性和主从同步是其关键特性，以下 是这些特性的详细解释：</p>
<ol>
<li><strong>Redis集群的故障转移</strong>：</li>
</ol>
<p>Redis集群的故障转移主要依赖于Redis Sentinel（哨兵）或Redis Cluster。</p>
<ul>
<li><strong>基于Redis Sentinel的故障转移</strong>：<!-- -->
<ul>
<li>Sentinel通过定期向主节点和从节点发送PING命令来监控它们的健康状态。</li>
<li>当主节点连续几次未能响应PING命令时，Sentinel将主节点标记为“主观下线”(SDOWN)。</li>
<li>当足够数量的Sentinel（由配置文件中的quorum参数指定）都标记主节点为SDOWN时，主节点会被标记为“客观下线”(ODOWN)，并从其中一个从节点中选择一个作为新的主节点。</li>
</ul>
</li>
<li><strong>基于Redis Cluster的故障转移</strong>：<!-- -->
<ul>
<li>Redis Cluster中的每个节点都负责监测与其相连的其他节点的健康状况，通过互相发送PING命令。</li>
<li>当某个节点检测到与其相连的主节点故障时，它会启动故障转移过程，并尝试将某个从节点提升为主节点。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>如何保证高可用</strong>：</li>
</ol>
<p>Redis通过主从复制和集群技术来保证高可用。</p>
<ul>
<li><strong>主从复制</strong>：通过将一个主节点的数据复制到多个从节点，实现数据的冗余备份。当主节点故障时，从节点可以接管服务，确保服务不中断。</li>
<li><strong>Redis Sentinel</strong>：除了监控和故障转移外，Sentinel还提供了配置管理和通知功能，进一步提高了Redis集群的可用性。</li>
<li><strong>Redis Cluster</strong>：通过将数据分布在多个节点上，实现了水平扩展和高可用。即使部分节点故障，集群也能继续提供服务。</li>
</ul>
<ol>
<li><strong>主从同步的过程</strong>：</li>
</ol>
<p>主从同步的过程主要包括全量同步和增量同步。</p>
<ul>
<li><strong>全量同步</strong>：<!-- -->
<ul>
<li>从节点连接主节点，发送SYNC  命令。</li>
<li>主节点执行BGSAVE命令生成RDB文件，并使用缓冲区记录在此期间执行的写命令。</li>
<li>主节点将RDB文件发送给从节点，并在发送期间继续记录写命令。</li>
<li>从节点加载RDB文件，并执行主节点发送的写命令，完成数据同步。</li>
</ul>
</li>
<li><strong>增量同步</strong>：在全量同步完成后，主节点会将新的写命令实时发送给从节点，保持数据的实时更新。</li>
</ul>
<ol>
<li><strong>RDB是什么</strong>：</li>
</ol>
<p>RDB是Redis的一种持久化方式，也称为快照持久化。它是将当前内存中的数据集快照写入磁盘，保存为RDB文件。当Redis重新启动时，可以读取RDB文件恢复数据。RDB的触发条件可以是手动触发或自动触发（如根据配置的时间间隔或数据变更量）。RDB的优点是恢复速度快，但可能会丢失故障发生后的数据。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2--redis-的大-key-怎么应对">2  Redis 的大 key 怎么应对？<a class="hash-link" aria-label="2  Redis 的大 key 怎么应对？的直接链接" title="2  Redis 的大 key 怎么应对？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#2--redis-的大-key-怎么应对">​</a></h2>
<p>Redis中的大key（BigKey）是指包含大量元素的复合数据类型，如列表、哈希、集合或有序集合等，它们的大小可能达到数MB甚至数百MB。大key在Redis中可能引发多种问题，如内存消耗过多、网络拥塞、服务延迟等。以下是一些建议的应对策略：</p>
<ol>
<li><strong>识别大key</strong>：
首先需要识别出 Redis 中的大key。可以使用<code>redis-cli</code>工具的<code>--bigkeys</code>选项来扫描并识别出大key。</li>
<li><strong>优化数据结构</strong>：
检查并优化存储在大key中的数据结构。例如，如果一个哈希（Hash）类型的key包含大量字段，可以考虑将其拆分成多个key；如 果一个列表（List）类型的key包含大量元素，可以考虑使用有序集合（Sorted Set）或其他更合适的数据结构。</li>
<li><strong>拆分大key</strong>：
如果可能的话，将大key拆分成多个小key。这可以通过将大key的value按照一定的规则拆分开来，然后使用多个key来存储这些拆分后的value。在拆分时，要确保数据的完整性和一致性。</li>
<li><strong>压缩value</strong>：
对于大key的value，如果其数据类型支持，可以使用序列化技术进行压缩处理。这样可以缩小value的空间占用，从而减少内存消耗。</li>
<li><strong>设置过期时间</strong>：
为大key设置合理的过期时间，以便在数据过期后自动删除，避免大key长时间占用内存。但需要注意的是，过期检查可能会带来一定的性能开销。</li>
<li><strong>监控与报警</strong>：
通过监控Redis的内存使用情况和大key的变化情况，及时发现并处理潜在的问题。可以设置报警阈值，当大key的大小超过一定阈值时触发报警，以便及时采取措施。</li>
<li><strong>限流与缓存</strong>：
在应用层对大key的访问进行限流，避免同时有大量请求访问同一个大key导致性能问题。同时，可以在Redis客户端开启本地缓存，减少对Redis的访问压力。</li>
<li><strong>删除或替换大key</strong>：
如果大key不再需要，或者其数据可以被其他方式替代，可以考虑直接删除大key或者将其替换成一个小key。但需要注意的是，删除大key可能会带来一定的性能开销，并且需要确保删除操作不会对其他业务造成影响。</li>
<li><strong>使用Redis集群</strong>：
如果单个Redis实例无法处理大key带来的性能问题，可以考虑使用Redis集群来水平扩展处理能力。Redis集群可以将数据分布在多个节点上，从而减轻单个节点的压力。</li>
<li><strong>定期审计和清理</strong>：
定期审计Redis中的数据，  识别并清理不再需要的大key和过时数据。这有助于保持Redis的性能和可用性。</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3-redis-如何做延时队列吗">3 redis 如何做延时队列吗？<a class="hash-link" aria-label="3 redis 如何做延时队列吗？的直接链接" title="3 redis 如何做延时队列吗？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#3-redis-如何做延时队列吗">​</a></h2>
<p>Redis 本身并不直接支持延时队列（Delayed Queue）的功能，但你可以通过结合其数据结构（如有序集合 <code>sorted set</code>）和特性（如键过期和发布/订阅）来实现延时队列的功能。以下是一些常见的方法来实现 Redis 延时队列：</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="方法一使用有序集合sorted-set">方法一：使用有序集合（Sorted Set）<a class="hash-link" aria-label="方法一：使用有序集合（Sorted Set）的直接链接" title="方法一：使用有序集合（Sorted Set）的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#方法一使用有序集合sorted-set">​</a></h3>
<p>你可以将任务作为有序集合的成员，将任务的执行时间作为分数（score）。然后，你可以使用一个循环任务（如使用定时任务框架如 cron、Celery 的周期性任务等）来定期检查有序集合中最早到期的任务，并执行它。</p>
<p>步骤如下：</p>
<ol>
<li>当一个延时任务被添加时，将其作为一个成员添加到有序集合中，并将任务的执行时间戳作为分数。</li>
<li>使用一个循环任务来检查有序集合中最早到期的任务（即分数最小的成员）。</li>
<li>如果当前时间已经超过了最早到期的任务的执行时间，则从有序集合中移除该任务并执行它。</li>
<li>重复上述步骤，直到没有到期任务为止。</li>
</ol>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="方法二使用键过期和发布订阅">方法二：使用键过期和发布/订阅<a class="hash-link" aria-label="方法二：使用键过期和发布/订阅的直接链接" title="方法二：使用键过期和发布/订阅的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#方法二使用键过期和发布订阅">​</a></h3>
<p>另一种方法是使用 Redis 的键过期和发布/订阅功能。</p>
<p>步骤如下：</p>
<ol>
<li>当一个延时任务被添加时，将其详细信息存储在一个字符串或哈希类型的键中，并设置该键的过期时间为任务的执行时间。</li>
<li>同时，为该键设置一个过期事件的监听器。当键过期时，监听器会发布一个消息到指定的频道（channel）。</li>
<li>创建一个订阅者来监听该频道。当收到消息时，订阅者从 Redis 中获取任务的详细信息并执行它。</li>
</ol>
<p>为了实现键过期事件的监听器，你可能需要使用 Redis 的键空间通知（Keyspace Notifications）功能，或者通过一些外部工具或框架（如 Lua 脚本、Redis 触发器、Redis 客户端库等）来实现。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="方法三使用第三方库或工具">方法三：使用第三方库或工具<a class="hash-link" aria-label="方法三：使用第三方库或工具的直接链接" title="方法三：使用第三方库或工具的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#方法三使用第三方库或工具">​</a></h3>
<p>除了上述手动实现方法外，还有一些第三方库或工具可以帮助你更容易地实现 Redis 延时队列。例如，<code>redis-delayed-job</code>、<code>bull</code>（基于 Redis 的队列库，支持延时队列）等都是不错的选择。这些库或工具通常提供了更高级别的抽象和更丰富的功能，可以简化延时队列的实现过程。</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="注意事项">注意事  项<a class="hash-link" aria-label="注意事项的直接链接" title="注意事项的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#注意事项">​</a></h3>
<ul>
<li>确保 Redis 服务器的性能和稳定性。延时队列可能会产生大量的读写操作和定时任务，因此需要对 Redis 服务器进行适当的优化和监控。</li>
<li>根据实际情况选择合适的实现方法。不同的实现方法有不同的优缺点和适用场景，需要根据具体需求来选择最适合的方法。</li>
<li>考虑并发和竞争条件。在多个任务同时到达或执行时，需要确保任务的正确性和顺序性。可能需要使用锁或其他同步机制来避免并发问题。</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="4-redis-支持哪几种数据类型redis-的特点">4 redis 支持哪几种数据类型？redis 的特点？<a class="hash-link" aria-label="4 redis 支持哪几种数据类型？redis 的特点？的直接链接" title="4 redis 支持哪几种数据类型？redis 的特点？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#4-redis-支持哪几种数据类型redis-的特点">​</a></h2>
<p>String、List、Set、Sorted Set、hashes</p>
<p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。</p>
<p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是1GB，不像 memcached 只能保存1MB的数据，因此 Redis 可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的memcached来用。</p>
<p>Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="5-使用-redis-有哪些好处">5 使用 redis 有哪些好处？<a class="hash-link" aria-label="5 使用 redis 有哪些好处？的直接链接" title="5 使用 redis 有哪些好处？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#5-使用-redis-有哪些好处">​</a></h2>
<ul>
<li>
<p>速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)</p>
</li>
<li>
<p>支持丰富数据类型，支持string，list，set，sorted set，hash</p>
</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="string">String<a class="hash-link" aria-label="String的直接链接" title="String的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#string">​</a></h3>
<p><strong>常用命令</strong> ：set/get/decr/incr/mget等；</p>
<p><strong>应用场景</strong> ：String 是最常用的一种数据类型，普通的 key/value 存储都可以归为此类；常规计数,微博数，粉丝数等。</p>
<p><strong>实现方式</strong>：String 在 redis 内部存储默认就是一个字符串，被 redisObject 所引用，当遇到 incr、decr 等操作时会转成数值型进行计算，此时 redisObject 的encoding字段为int。String 数据结构是简单的Key-Value类型，value不仅可以是String，也可以是数字。</p>
<p>**数据结构：**内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如图所示：</p>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122209107.png" alt="image-20240512220946015" class="img_CujE"></div><p></p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="hash">Hash<a class="hash-link" aria-label="Hash的直接链接" title="Hash的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#hash">​</a></h3>
<p><strong>常用命令</strong> ：hget/hset/hgetall等</p>
<p><strong>应用场景</strong> ：我们要存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日；存储用户信息，商品信息等等。例如修真院的首页的职业信息，只是简单的信息集合，我们可以直接将它储存到Redis中，在读取的过程中就不用序列化对象，直接操作。</p>
<p><strong>实现方式</strong>：Redis 的 Hash 实际是内部存储的 Value 为一个 HashMap，并提供了直接存取这个 Map 成员的接口。如图所示，Key 是用户ID,  value是一个Map。这个Map 的key是成员的属性名，value是属性值。这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field)，也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据。当前HashMap的实现有两种方式：当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的 HashMap 结构，这时对应的value的redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap,此时redisObject的encoding字段为int。</p>
<p>**数据结构：**Redis Hash 通过分桶的方式解决 hash 冲突。它是无序字典。内部实现结构是同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。第一维是数组，第二维是链表。数组中存储的是第二维链表的第一个元素的指针。</p>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122217503.png" alt="image-20240512221737450" class="img_CujE"></div><p></p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="list">List<a class="hash-link" aria-label="List的直接链接" title="List的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#list">​</a></h3>
<p><strong>常用命令</strong> ：lpush/rpush/lpop/rpop/lrange等；</p>
<p><strong>应用场景</strong> ：Redis list的应用场景 非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现；</p>
<p><strong>实现方式</strong>：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p>
<p>**数据结构：**Redis 的列表相当于 Java 语言中的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>
<p><strong>list 的特点是:</strong></p>
<ol>
<li>有序</li>
<li>可以重复</li>
<li>右边进左边出或者左边进右边出，则列表可以充当队列</li>
<li>左边进左边出或者右边进右边出，则列表可以充当栈</li>
</ol>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122224120.png" alt="image-20240512222457082" class="img_CujE"></div><p></p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="set">Set<a class="hash-link" aria-label="Set的直接链接" title="Set的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#set">​</a></h3>
<p><strong>常用命令</strong> ：sadd/spop/smembers/sunion等；</p>
<p><strong>应用场景</strong> ：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且set提供了判断某个成员是否在一个set 集合内的重要接口，这个也是list所不能提供的；</p>
<ol>
<li>共同好友、二度好友</li>
<li>利用唯一性，可以统计访问网站的所有独立 IP</li>
<li>好友推荐的时候，根据 tag 求交集，大于某个 threshold 就可以推荐</li>
</ol>
<p><strong>实现方式</strong>：set 的内部实现是一个 value 永远为 null 的 HashMap，实际就是通过计算 hash 的方式来快速排重的，这也是 set 能提供判断一个成员是否在集合内的原因。</p>
<p><strong>数据结构:</strong> set 和字典非常类似，其内部实现就是上述的 hashTable 的特殊实现，与字典不同的地方有两点：</p>
<ol>
<li>只关注key值，所有的value都是NULL。</li>
</ol>
<ol start="2">
<li>在新增数据时会进行去重。</li>
</ol>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122234757.png" alt="image-20240512223452684" class="img_CujE"></div><p></p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="sorted-set">Sorted Set<a class="hash-link" aria-label="Sorted Set的直接链接" title="Sorted Set的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#sorted-set">​</a></h3>
<p><strong>常用命令</strong> ：zadd/zrange/zrem/zcard等；</p>
<p><strong>应用场景</strong> ：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</p>
<p><strong>实  现方式</strong>：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122247534.jpg" alt="img" class="img_CujE"></div><p></p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="6-redis-为什么那么快">6 redis 为什么那么快？<a class="hash-link" aria-label="6 redis 为什么那么快？的直接链接" title="6 redis 为什么那么快？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#6-redis-为什么那么快">​</a></h2>
<ol>
<li><strong>完全基于内存</strong>，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是<strong>O(1)</strong>；</li>
<li><strong>数据结构简单</strong>，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</li>
<li><strong>采用单线程</strong>，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li><strong>用多路 I/O 复用模型</strong>，非阻塞 IO；</li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="7-缓存穿透是什么如何解决">7 缓存穿透是什么，如何解决？<a class="hash-link" aria-label="7 缓存穿透是什 么，如何解决？的直接链接" title="7 缓存穿透是什么，如何解决？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#7-缓存穿透是什么如何解决">​</a></h2>
<p><strong>缓存穿透</strong> 指查询一个一定不存在的数据，由于缓存是不命中时，需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求，都要到数据库去查询，进而给数据库带来压力。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>将空数据也缓存：占有一定的空间，可能带来短期的数据不一致。如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟，</li>
<li>使用布隆过滤器 bloom filter：是一种预防的方案，占用空间少、误差可控。将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="8-什么是缓存雪崩如何解决">8 什么是缓存雪崩，如何解决？<a class="hash-link" aria-label="8 什么是缓存雪崩，如何解决？的直接链接" title="8 什么是缓存雪崩，如何解决？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#8-什么是缓存雪崩如何解决">​</a></h2>
<p><strong>缓存雪崩</strong> 是指在某一个时间段，缓存集中过期失效。当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</p>
<p><strong>解决方案</strong></p>
<ol>
<li><strong>过 期时间设置随机值</strong>: 在原有的失效时间上加上一个随机值，比如，1-5 分钟随机。这样就避免了同一时间大量数据过期现象的发生而导致缓存雪崩。</li>
<li><strong>分布式部署且均匀分布热点数据</strong>: 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。同时，分布式集群可以防止Redis宕机导致缓存雪崩的问题。</li>
<li><strong>热点数据永不过期:</strong> 设置热点数据永远不过期。</li>
<li><strong>使用熔断机制</strong>。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</li>
<li><strong>提高数据库的容灾能力</strong>，可以使用分库分表，读写分离的策略。</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="9-造成缓存雪崩的原因是什么">9 造成缓存雪崩的原因是什么？<a class="hash-link" aria-label="9 造成缓存雪崩的原因是什么？的直接链接" title="9 造成缓存雪崩的原因是什么？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#9-造成缓存雪崩的原因是什么">​</a></h2>
<p>造成缓存雪崩 的关键在于<strong>在同一时间大规模的key失效</strong>。出现这个问题有下面几种可能：</p>
<ul>
<li>
<p>第一种可能是Redis宕机，</p>
</li>
<li>
<p>第二种可能是采用了相同的过期时间。</p>
</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="10-什么是缓存击穿如何解决">10 什么是缓存击穿，如何解决？<a class="hash-link" aria-label="10 什么是缓存击穿，如何解决？的直接链接" title="10 什么是缓存击穿，如何解决？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#10-什么是缓存击穿如何解决">​</a></h2>
<p>某一个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><strong>加互斥锁</strong>。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。</li>
<li>JVM 锁保证了在单台服务器上只有一个请求走到数据库，通常来说已经足够保证数据库的压力大大降低，同时在性能上比分布式锁更好。
需要注意的是，<strong>无论是使用“分布式锁”，还是“JVM 锁”，加锁时要按 key 维度去加锁。</strong></li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="11-聊聊redis-事务机制">11 聊聊Redis 事务机制？<a class="hash-link" aria-label="11 聊聊Redis 事务机制？的直接链接" title="11 聊聊Redis 事务机制？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#11-聊聊redis-事务机制">​</a></h2>
<p>Redis 通过 MULTI、EXEC、WATCH等一组命令集合，来实现事务机制。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。简言之，<strong>Redis 事务就是顺序性、一次性、排他性的执行一个队列中的一系列命令。</strong></p>
<p>Redis 执行事务的流程如下：开始事务（MULTI）、命令入队、执行事务（EXEC）、撤销事务（DISCARD ）。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="12-在生成-rdb-期间redis-可以同时处理写请求么">12 在生成 RDB 期间，Redis 可以同时处理写请求么？<a class="hash-link" aria-label="12 在生成 RDB 期间，Redis 可以同时处理写请求么？的直接链接" title="12 在生成 RDB 期间，Redis 可以同时处理写请求么？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#12-在生成-rdb-期间redis-可以同时处理写请求么">​</a></h2>
<p>可以的，Redis 提供两个指令生成 RDB，分别是 save 和 bgsave。</p>
<p>如果是save指令，会阻塞，因为是主线程执行的。</p>
<p>如果是bgsave指令，是fork一个子进程来写入RDB文件的，快照持久化完全交给子进程来处理，父进程则可以继续处理客户端的请求。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="13-如何选择合适的持久化方式">13 如何选择合适的持久化方式？<a class="hash-link" aria-label="13 如何选择合适的持久化方式？的直接链接" title="13 如何选择合适的持久化方式？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#13-如何选择合适的持久化方式">​</a></h2>
<p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 <strong>RDB 恢复数据集的速度也要比 AOF 恢复的速度要快</strong>，除此之外，使用 RDB 还可以避免 AOF 程序的bug。</p>
<p>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="14-什么是缓存预热">14 什么是缓存预热?<a class="hash-link" aria-label="14 什么是缓存预热?的直接链接" title="14 什么是缓存预热?的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#14-什么是缓存预热">​</a></h2>
<p><strong>缓存预热</strong> 就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p><strong>解决方案</strong></p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="15-redis是单线程还是多线程">15 Redis是单线程还是多线程？<a class="hash-link" aria-label="15 Redis是单线程还是多线程？的直接链接" title="15 Redis是单线程还是多线程？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#15-redis是单线程还是多线程">​</a></h2>
<p>Redis6.0 采用多线程 IO，不过命令的执行还是单线程的。Redis6.0 之前，IO 线程和执行线程都是单线程的。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="16-redis-key-的过期时间和永久有效分别怎么设置">16 Redis key 的过期时间和永久有效分别怎么设置？<a class="hash-link" aria-label="16 Redis key 的过期时间和永久有效分别怎么设置？的直接链接" title="16 Redis key 的过期时间和永久有效分别怎么设置？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#16-redis-key-的过期时间和永久有效分别怎么设置">​</a></h2>
<p>分别是 EXPIRE 和 PERSIST 命令进行设置。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="17-热-key--重键问题如何解决">17 热 Key  重键问题如何解决？<a class="hash-link" aria-label="17 热 Key  重键问题如何解决 ？的直接链接" title="17 热 Key  重键问题如何解决？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#17-热-key--重键问题如何解决">​</a></h2>
<p>加锁重键（互斥锁）：</p>
<p>热键不过期：在缓存中创建一个时间戳，先判断时间戳是否过期，如果没有过期返回原数据，过期了则访问数据源。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="18-什么是布隆过滤器">18 什么是布隆过滤器？<a class="hash-link" aria-label="18 什么是布隆过滤器？的直接链接" title="18 什么是布隆过滤器？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#18-什么是布隆过滤器">​</a></h2>
<p><strong>布隆过滤器</strong>是一个叫“布隆”的人提出的，它本身是一个很长的二进制向量，既然是二进制的向量，那么显而易见的，存放的不是 0，就是 1。布隆过滤器是一种由位数组和多个哈希函数组成概率数据结构，返回两种结果可能存在和一定不存在。布隆过滤器里的一个元素由多个状态值共同确定。位数组存储状态值，哈希函数计算状态值的位置。</p>
<p>**优点：**由于存放的不是完整的数据，所以占用的内存很少，而且新增，查询速度够快；</p>
<p><strong>缺点：</strong> 随着数据的增加，误判率随之增加；无法做到删除数据；只能判断数据是否一定不存在，而无法判断数据是否一定存在。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="19-redis-的hash冲突怎么办">19 Redis 的Hash冲突怎么办?<a class="hash-link" aria-label="19 Redis 的Hash冲突怎么办?的直接链接" title="19 Redis 的Hash冲突怎么办?的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#19-redis-的hash冲突怎么办">​</a></h2>
<p>Redis 作为一个 K-V 的内存数据库，它使用用一张全局的哈希来保存所有的键值对。这张哈希表， 有多个哈希桶组成，哈希桶中的 entry 元素保存了 key 和 value 指针，<strong>其中 key 指向了实际的键，value 指向了实际的值。</strong></p>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122246757.png" alt="image-20240512224553337" class="img_CujE"></div><p></p>
<p>所谓的哈希冲突通是指过不同的key，计算出一样的哈希值，导致落在同一个哈希桶中。</p>
<p>Redis 为了解决哈希冲突，采用了链式哈希。链式哈希是指同一个哈希桶中，多个元素用一个链表来保存，它们之间依次用指针连接。</p>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122253358.png" alt="image-20240512225328329" class="img_CujE"></div><p></p>
<p>因为哈希冲突链上的元素只能通过指针逐一查找再操作，所以当往哈希表插入数据很多，冲突也会越多，冲突链表就会越长，那查询效率就会降低了。为了保持高效，Redis 会对哈希表做rehash操作，也就是增加哈希桶，减少冲突。为了rehash更高效，Redis还默认使用了两个全局哈希表，一个用于当前使用，称为主哈希表，一个用于扩容，称为备用哈希表。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="20-说说-redis-哈希槽的概念">20 说说 Redis 哈希槽的概念？<a class="hash-link" aria-label="20 说说 Redis 哈希槽的概念？的直接链接" title="20 说说 Redis 哈希槽的概念？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#20-说说-redis-哈希槽的概念">​</a></h2>
<p>Redis 集群没有使用一致性 hash, 而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="21-怎么实现redis-的高可用">21 怎么实现Redis 的高可用？<a class="hash-link" aria-label="21 怎么实现Redis 的高可用？的直接链接" title="21 怎么实现Redis 的高可用？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#21-怎么实现redis-的高可用">​</a></h2>
<p>我们在项目中使用 Redis，肯定不会是单点部署 Redis 服务的。因为，单点部署一旦宕机，就不可用了。为了实现高可用，通常的做法是，将数据库复制多个副本以部署在不同的服务器上，其中一台挂了也可以继续提供服务。Redis 实现高可用有三种部署模式：主从模式，哨兵模式，集群模式。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="22-redis主从复制的原理">22 Redis主从复制的原理？<a class="hash-link" aria-label="22 Redis主从复制的原理？的直接链接" title="22 Redis主从复制的原理？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#22-redis主从复制的原理">​</a></h2>
<p>主从模式中 Redis 部署了多台机器，有负责读写操作主节点和只负责读操作从节点，从节点的数据来自主节点，实现原理就是主从复制机制。主从复制包括全量复制，增量复制两种。一般当 slave 第一次启动连接 master，或者认为是第一次连接，就采用全量复制，全量复制流程如下：</p>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122308719.png" alt="image-20240512230807681" class="img_CujE"></div><p></p>
<ol>
<li>slave 发送 sync 命令到 master。</li>
<li>master 接收到 SYNC 命令后，执行 bgsave 命令，生成 RDB 全量文件。</li>
<li>master 使用缓冲区，记录 RDB 快照生成期间的所有写命令。</li>
<li>master 执行完 bgsave 后，向所有 slave 发送 RDB 快照文件。</li>
<li>slave 收到 RDB 快照文件后，载入、解析收到的快照。</li>
<li>master 使用缓冲区，记录 RDB 同步期间生成的所有写的命令。</li>
<li>master 快照发送完毕后，开始向 slave 发送缓冲区中的写命令;</li>
<li>salve 接受命令请求，并执行来自 master 缓冲区的写命令</li>
</ol>
<p>redis2.8版本之后，已经使用 psync 来替代 sync，因为 sync 命令非常消耗系统资源，psync 的效率更高。</p>
<p>slave 与 master 全量同步之后，master 上的数据，如果再次发生更新，就会触发增量复制。</p>
<p>当 master 节点发生数据增减时，就会触发 replicationFeedSalves() 函数，接下来在 Master 节点上调用的每一个命令会使用 replicationFeedSlaves() 来同步到 Slave节点。执行此函数之前呢，master 节点会判断用户执行的命令是否有数据更新，如果有数据更新的话，并且 slave 节点不为空，就会执行此函数。这个函数作用就是：把用户执行的命令发送到所有的 slave 节点，让 slave 节点执行。流程如下：</p>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122315171.png" alt="image-20240512231510089" class="img_CujE"></div><p></p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="23-什么是哨兵机制">23 什么是哨兵机制?<a class="hash-link" aria-label="23 什么是哨兵机制?的直接链接" title="23 什么是哨兵机制?的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#23-什么是哨兵机制">​</a></h2>
<p>Redis 的哨兵 (sentinel) 系统用于管理多个 Redis 服务器,该系统执行以下三个任务:</p>
<ol>
<li>监控 (Monitoring): 哨兵( sentinel ) 会不断地检查你的 Master 和 Slave 是否运作正常。</li>
<li>提醒 (Notification): 当被监控的某个 Redis 出现问题时, 哨兵 (sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移(Automatic failover): 当一个 Master 不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操  作,它会将失效 Master 的其中一个 Slave 升级为新的 Master, 并让失效 Master 的其他 Slave 改为复制新的 Master; 当客户端试图连接失效的 Master 时, 集群也会向客户端返回新 Master 的地址, 使得集群可以使用新 Master 代替失效 Master。</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="24-哨兵机制的作用">24 哨兵机制的作用？<a class="hash-link" aria-label="24 哨兵机制的作用？的直接链接" title="24 哨兵机制的作用？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#24-哨兵机制的作用">​</a></h2>
<p>监控主数据库和从数据库是否正常运行。</p>
<p>主数据库出现故障时，可以自动将从数据库转换为主数据库，实现自动切换。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="25-哨兵机制-sentinel-的高可用是如何实现">25 哨兵机制 (sentinel) 的高可用是如何实现？<a class="hash-link" aria-label="25 哨兵机制 (sentinel) 的高可用是如何实现？的直接链接" title="25 哨兵机制 (sentinel) 的高可用是如何实现？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#25-哨兵机制-sentinel-的高可用是如何实现">​</a></h2>
<p>当主节点出现故障时，由 Redis Sentinel 自动完成故障发现和转移，并通知应用方，实现高可用性。</p>
<p>其实整个过程只需要一个哨兵节点来完成，首先使用Raft算法（选举算法）实现选举机制，选出一个哨兵节点来完成转移和通知</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="26-哨兵核心点">26 哨兵核心点？<a class="hash-link" aria-label="26 哨兵核心点？的直接链接" title="26 哨兵核心点？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#26-哨兵核心点">​</a></h2>
<ol>
<li>哨兵集群至少要 3 个节点，来确保自己的健壮性</li>
<li>redis 主从 + sentinel 的架构，是不会 保证数据的零丢失的，它是为了保证 redis 集群的高可用.</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="27-redis-哨兵主备切换的时候会有数据丢失问题吗">27 Redis 哨兵主备切换的时候会有数据丢失问题吗？<a class="hash-link" aria-label="27 Redis 哨兵主备切换的时候会有数据丢失问题吗？的直接链接" title="27 Redis 哨兵主备切换的时候会有数据丢失问题吗？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#27-redis-哨兵主备切换的时候会有数据丢失问题吗">​</a></h2>
<p>会有，主要考虑下面两种情况。</p>
<ol>
<li>主从异步复制导致的数据丢失：redis master 和 slave 数据复制是异步的，这样就有可能会出现部分数据还没有复制到 slave 中，master 就挂掉了，那么这部分的数据就会丢失了</li>
<li>脑裂导致的数据丢失：脑裂其实就是网络分区导致的现象，比如，我们的 master 机器网络突然不正常了发生了网络分区，和其他的 slave 机器不能正常通信了，其实 master 并没有挂还活着好好的呢，但是哨兵可不是吃闲饭的啊，它会认为 master 挂掉了啊，那么问题来了，client 可能还在继续写 master 的呀，还没来得及更新到新的master 呢，那这部分数据就会丢失。</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="28-slave-到-master-选举算法">28 slave 到 master 选举算法？<a class="hash-link" aria-label="28 slave 到 master 选举算法？的直接链接" title="28 slave 到 master 选举算法？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#28-slave-到-master-选举算法">​</a></h2>
<p>如果一个 master 被认为宕机了，而且 majority多 数哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，</p>
<p>此时首先要选举一个 slave 来，主要通过下面几个步骤：</p>
<ol>
<li>slave 跟 master 断开  连接的时长（断开时间越短优先级越高）</li>
<li>slave 优先级（在配置文件中的配置，slave priority 越低，优先级就越高。）</li>
<li>复制offset（哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。）</li>
<li>run id（如果上面两个条件都相同，那么选择一个run id 比较小的那个 slave）</li>
</ol>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405122323677.jpg" alt="img" class="img_CujE"></div><p></p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="29-介绍下-redis-cluster-">29 介绍下 Redis Cluster ？<a class="hash-link" aria-label="29 介绍下 Redis Cluster ？的直接链接" title="29 介绍下 Redis Cluster ？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#29-介绍下-redis-cluster-">​</a></h2>
<p>redis 从 3.0 开始支持集群功能。redis 集群采用无中心节点方式实现，无需 proxy 代理，客户端直接与 redis 集群的每个节点连接，根据同样的 hash 算法计算出 key 对应的 slot，然后直接在 slot 对应的 redis 节点上执行命令。在 redis 看来，响应时间是最苛刻的条件，增加一层带来的开销是redis不能接受的。因此，redis 实现了客户端对节点的直接访问，为了去中心化，节点之间通过 gossip 协议交换互相的状态，以及探测新加入的节点信息。redis 集群支持动态加入节点，动态迁移 slot，以及自动故障转移。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="30-mysql里有2000w数据redis中只存20w的数据如何保证redis中的数据都是热点数据">30 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？<a class="hash-link" aria-label="30 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？的直接链接" title="30 MySQL里有2000w数据，redis中只存20w  的数据，如何保证redis中的数据都是热点数据？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#30-mysql里有2000w数据redis中只存20w的数据如何保证redis中的数据都是热点数据">​</a></h2>
<p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="31-redis-如何做内存优化">31 Redis 如何做内存优化？<a class="hash-link" aria-label="31 Redis 如何做内存优化？的直接链接" title="31 Redis 如何做内存优化？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#31-redis-如何做内存优化">​</a></h2>
<p>可以好好利用 Hash, list, sorted set, set等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="32-假如-redis-里面有1亿个-key其中有-10w-个-key-是以某个固定的已知的前缀开头的如果将它们全部找出来">32 假如 Redis 里面有1亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<a class="hash-link" aria-label="32 假如 Redis 里面有1亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？的直接链接" title="32 假如 Redis 里面有1亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#32-假如-redis-里面有1亿个-key其中有-10w-个-key-是以某个固定的已知的前缀开头的如果将它们全部找出来">​</a></h2>
<p>使用 keys 指令可以扫出指定模式的 key列表。</p>
<p>对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？</p>
<p>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="33-redis-如何做大量数据插入">33 Redis 如何做大量数据插入？<a class="hash-link" aria-label="33 Redis 如何做大量数据插入？的直接链接" title="33 Redis 如何做大量数据插入？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#33-redis-如何做大量数据插入">​</a></h2>
<p>Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="34-redis-常见性能问题和解决方案">34 Redis 常见性能问题和解决方案？<a class="hash-link" aria-label="34 Redis 常见性能问题和解决方案？的直接链接" title="34 Redis 常见性能问题和解决方案？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#34-redis-常见性能问题和解决方案">​</a></h2>
<ol>
<li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个 Slave 开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF在重写的时候会占大量的 CPU 和内存资源，导致服务 load过高，出现短暂服务暂停现象。</li>
<li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master <code>&lt;–</code> Slave1 <code>&lt;–</code> Slave2 <code>&lt;–</code> Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="35-如何解决-redis-的并发竞争-key-问题">35 如何解决 Redis 的并发竞争 Key 问题?<a class="hash-link" aria-label="35 如何解决 Redis 的并发竞争 Key 问题?的直接链接" title="35 如何解决 Redis 的并发竞争 Key 问题?的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#35-如何解决-redis-的并发竞争-key-问题">​</a></h2>
<p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁，如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）。基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在 zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。  完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="36-简答描述-redis-是实现分布式锁">36 简答描述 Redis 是实现分布式锁?<a class="hash-link" aria-label="36 简答描述 Redis 是实现分布式锁?的直接链接" title="36 简答描述 Redis 是实现分布式锁?的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#36-简答描述-redis-是实现分布式锁">​</a></h2>
<p>Redis 为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis 中可以使用 SETNX 命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作。其中SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。
返回值：设置成功，返回 1 。设置失败，返回 0 。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="37-怎么保证缓存和数据库数据的一致性">37 怎么保证缓存和数据库数据的一致性？<a class="hash-link" aria-label="37 怎么保证缓存和数据库数据的一致性？的直接链接" title="37 怎么保证缓存和数据库数据的一致性？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#37-怎么保证缓存和数据库数据的一致性">​</a></h2>
<p>从理论上说，只要我们设置了合理的键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。除了设置过期时间，我们还可以通过新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。一般有如下四种方 案，具体如下：</p>
<ol>
<li>先更新数据库，后更新缓存</li>
<li>先更新缓存，后更新数据库</li>
<li>先删除缓存，后更新数据库</li>
<li>先更新数据库，后删除缓存</li>
</ol>
<p>第一种方案存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。</p>
<p>第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。</p>
<p>目前主要用第三和第四种方案。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="38-redis-内存淘汰策略有哪些">38 Redis 内存淘汰策略有哪些？<a class="hash-link" aria-label="38 Redis 内存淘汰策略有哪些？的直接链接" title="38 Redis 内存淘汰策略有哪些？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#38-redis-内存淘汰策略有哪些">​</a></h2>
<p>Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
全局的键空间选择性移除：</p>
<p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</p>
<p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</p>
<p>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
设置过期时间的键空间选择性移除</p>
<p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除 近 少使用的key。</p>
<p>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</p>
<p>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="39-reids-的过期键值的删除策略">39 reids 的过期键值的删除策略？<a class="hash-link" aria-label="39 reids 的过期键值的删除策略？的直接链接" title="39 reids 的过期键值的删除策略？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#39-reids-的过期键值的删除策略">​</a></h2>
<p>Redis 的过期键的删除策略是指当 Redis 中的缓存的 key 过期了，Redis要如何处理。</p>
<p>Redis中提供了三种删除策略：</p>
<p>1.定时删除</p>
<p>当放入数据后，设置一个定时器，当定时器读秒完毕后，将对应的数据从dict中删除。
优点： 内存友好，数据一旦过期就会被删除
缺点： CPU不友好，定时器耗费CPU资源，并且频繁的执行清理操作也会耗费CPU资源。用时间换空间
2.惰性删除
当数据过期的时候，不做任何操作。当访问数据的时候，查看数据是否过期，如果过期返回null，并且将数据从内存中清除。如果没过期，就直接返回数据。
优点： CPU友好，数据等到过期并且被访问的时候，才会删除。
缺点： 内存不友好，会占用大量内存。用空间换时间
3.定期删除
定期删除是定时删除和惰性删除的折中方案。每隔一段时间对redisServer中的所有redisDb的expires依次进行随机抽取检查。
Redis 中有一个 server.hz 定义了每秒钟执行定期删除的次数，每次执行的时间为250ms/server.hz。Redis中会维护一个current_db变量来标志当前检查的数据库。current_db++，当超过数据库的数量的时候，会重新从0开始。
定期检查就是执行一个循环，循环中的每轮操作会从current_db对应的数据库中随机依次取出w个key，查看其是否过期。如果过期就将其删除， 并且记录删除的key的个数。如果过期的key个数大于w25%，就会继续检查当前数据库，当过期的key小于w25%，会继续检查下一个数据库。当执行时间超过规定的最大执行时间的时候，会退出检查。一次检查中可 以检查多个数据库，但是最多检查数量是redisServer中的数据库个数，也就是最多只能从当前位置检查一圈。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="40-redis-是单线程的如何提高多核-cpu-的利用率">40 Redis 是单线程的，如何提高多核 CPU 的利用率？<a class="hash-link" aria-label="40 Redis 是单线程的，如何提高多核 CPU 的利用率？的直接链接" title="40 Redis 是单线程的，如何提高多核 CPU 的利用率？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#40-redis-是单线程的如何提高多核-cpu-的利用率">​</a></h2>
<p>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服 务器来使用，在某些时候，无论如何一个服务器是不够的， 所以， 如果你想使用多个 CPU，你可以考虑一下分片（shard）。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="41-为什么要做-redis-分区">41 为什么要做 Redis 分区？<a class="hash-link" aria-label="41 为什么要做 Redis 分区？的直接链接" title="41 为什么要做 Redis 分区？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#41-为什么要做-redis-分区">​</a></h2>
<p>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升，Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="42-你知道有哪些-redis-分区实现方案">42 你知道有哪些 Redis 分区实现方案？<a class="hash-link" aria-label="42 你知道有哪些 Redis 分区实现方案？的直接链接" title="42 你知道有哪些 Redis 分区实现方案？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#42-你知道有哪些-redis-分 区实现方案">​</a></h2>
<ol>
<li><strong>客户端分区</strong>就是在客户端就已经决定数据会被存储到哪个 redis 节点或者从哪个 redis 节点读取。大多数客户端已经实现了客户端分区。</li>
<li><strong>代理分区</strong> 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy。</li>
<li><strong>查询路由(Query routing)</strong> 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="43-redis-分区有什么缺点">43 Redis 分区有什么缺点？<a class="hash-link" aria-label="43 Redis 分区有什么缺点？的直接链接" title="43 Redis 分区有什么缺点？的直接链接" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#43-redis-分区有什么缺点">​</a></h2>
<ol>
<li>涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个 key，则不能使用 Redis 事务。</li>
<li>分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ol>
<p></p><div class="zjImgContainer_kJPg"><img decoding="async" loading="lazy" src="https://img.zbus.top/zbus/blog202405130004166.jpg" alt="img" class="img_CujE"></div><p></p>
<blockquote>
<p>内容收集于网络并整理:</p>
<p>1、<a href="http://www.bjpowernode.com/redismst.html" target="_blank" rel="noopener noreferrer">Redis 面试题</a></p>
<p>2、<a href="https://blog.csdn.net/m0_60259116/article/details/137345301?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-137345301-blog-127846944.235%5Ev43%5Epc_blog_bottom_relevance_base7&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-137345301-blog-127846944.235%5Ev43%5Epc_blog_bottom_relevance_base7&amp;utm_relevant_index=5" target="_blank" rel="noopener noreferrer">面试不慌，史上最全 Redis 面试题（含答案</a></p>
</blockquote></div><div class="noticeCardContainer_M8qB"><div class="theme-admonition theme-admonition-danger admonition_Gfwi alert alert--danger"><div class="admonitionHeading_f1Ed"><span class="admonitionIcon_kpSf">💡</span>本文声明</div><div class="admonitionContent_UjKb"><p>转载请注明出处，谢谢合作！转载本文请声明原文章链接如下:</p><p><strong>原文链接: </strong><a href="https://zbus.top/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong">https://zbus.top/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong</a></p><p><strong>作者: </strong><a href="https://zbus.top">Z 不殊</a></p><p><a href="https://zbus.top" target="_blank" rel="noopener noreferrer">Z 不殊</a> 致力于分享有价值的信息和知识。我们尊重并保护知识产权。本文仅代表作者观点，不代表任何立场。 如果本文有所侵权，请联系作者删除或修改！</p></div></div></div><div>Loading Comments...</div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_d0Lz tagRegular_bmnp" href="/docs/tags/随笔">随笔</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link border-2 border-link hover:bg-[#a1d8f71b] pagination-nav__link--prev" href="/docs/category/后端面试相关java"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">后端面试相关（java）</div></a><a class="pagination-nav__link border-2 border-link hover:bg-[#a1d8f71b] pagination-nav__link--next" href="/docs/面试相关/zookeeper mian-shi-ti-gui-zong"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">zookeeper 面试题归总</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#1-redis-集群如何进行故障转移如何保证高可用主从同步的过程-rdb-是什么">1 redis 集群如何进行故障转移？如何保证高可用？主从同步的过程？ Rdb 是什么？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#2--redis-的大-key-怎么应对">2  Redis 的大 key 怎么应对？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#3-redis-如何做延时队列吗">3 redis 如何做延时队列吗？</a><ul><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#方法一使用有序集合sorted-set">方法一：使用有序集合（Sorted Set）</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#方法二使用键过期和发布订阅">方法二：使用键过期和发布/订阅</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#方法三使用第三方库或工具">方法三：使用第三方库或工具</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#注意事项">注意事项</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#4-redis-支持哪几种数据类型redis-的特点">4 redis 支持哪几种数据类型？redis 的特点？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#5-使用-redis-有哪些好处">5 使用 redis 有哪些好处？</a><ul><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#string">String</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#hash">Hash</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#list">List</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#set">Set</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#sorted-set">Sorted Set</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#6-redis-为什么那么快">6 redis 为什么那么快？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#7-缓存穿透是什么如何解决">7 缓存穿透是什么，如何解决？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#8-什么是缓存雪崩如何解决">8 什么是缓存雪崩，如何解决？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#9-造成缓存雪崩的原因是什么">9 造成缓存雪崩的原因是什么？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#10-什么是缓存击穿如何解决">10 什么是缓存击穿，如何解决？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#11-聊聊redis-事务机制">11 聊聊Redis 事务机制？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#12-在生成-rdb-期间redis-可以同时处理写请求么">12 在生成 RDB 期间，Redis 可以同时处理写请求么？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#13-如何选择合适的持久化方式">13 如何选择合适的持久化方式？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#14-什么是缓存预热">14 什么是缓存预热?</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#15-redis是单线程还是多线程">15 Redis是单线程还是多线程？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#16-redis-key-的过期时间和永久有效分别怎么设置">16 Redis key 的过期时间和永久有效分别怎么设置？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#17-热-key--重键问题如何解决">17 热 Key  重键问题如何解决？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#18-什么是布隆过滤器">18 什么是布隆过滤器？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#19-redis-的hash冲突怎么办">19 Redis 的Hash冲突怎么办?</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#20-说说-redis-哈希槽的概念">20 说说 Redis 哈希槽的概念？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#21-怎么实现redis-的高可用">21 怎么实现Redis 的高可用？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#22-redis主从复制的原理">22 Redis主从复制的原理？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#23-什么是哨兵机制">23 什么是哨兵机制?</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#24-哨兵机制的作用">24 哨兵机制的作用？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#25-哨兵机制-sentinel-的高可用是如何实现">25 哨兵机制 (sentinel) 的高可用是如何实现？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#26-哨兵核心点">26 哨兵核心点？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#27-redis-哨兵主备切  换的时候会有数据丢失问题吗">27 Redis 哨兵主备切换的时候会有数据丢失问题吗？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#28-slave-到-master-选举算法">28 slave 到 master 选举算法？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#29-介绍下-redis-cluster-">29 介绍下 Redis Cluster ？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#30-mysql里有2000w数据redis中只存20w的数据如何保证redis中的数据都是热点数据">30 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#31-redis-如何做内存优化">31 Redis 如何做内存优化？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#32-假如-redis-里面有1亿个-key其中有-10w-个-key-是以某个固定的已知的前缀开头的如果将它们全部找出来">32 假如 Redis 里面有1亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#33-redis-如何做大量数据插入">33 Redis 如何做大量数据插入？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#34-redis-常见性能问题和解决方案">34 Redis 常见性能问题和解决方案？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#35-如何解决-redis-的并发竞争-key-问题">35 如何解决 Redis 的并发竞争 Key 问题?</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#36-简答描述-redis-是实现分布式锁">36 简答描述 Redis 是实现分布式锁?</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#37-怎么保证缓存和数据库数据的一致性">37 怎么保证缓存和数据库数据的一致性？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#38-redis-内存淘汰策略有哪些">38 Redis 内存淘汰策略有哪些？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#39-reids-的过期键值的删除策略">39 reids 的过期键值的删除策略？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#40-redis-是单线程的如何提高多核-cpu-的利用率">40 Redis 是单线程的，如何提高多核 CPU 的利用率？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#41-为什么要做-redis-分区">41 为什么要做 Redis 分区？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#42-你知道有哪些-redis-分区实现方案">42 你知道有哪些 Redis 分区实现方案？</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/面试相关/redis xiang-guan-mian-shi-ti-gui-zong#43-redis-分区有什么缺点">43 Redis 分区有什么缺点？</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">总结类</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">文档</a></li><li class="footer__item"><a class="footer__link-item" position="right" href="/blog">博客</a></li><li class="footer__item"><a class="footer__link-item" position="right" href="/project">项目</a></li></ul></div><div class="col footer__col"><div class="footer__title">交流社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" position="right" href="/friends">友链</a></li><li class="footer__item">
                                    <a href="https://docusaurus.io/zh-CN/" target="_blank" rel="noreferrer noopener">
                                      <img src="/img/buildwith.png" alt="build with docusaurus" width="120" height="50">
                                    <a>
                                    </a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">
            <p style="margin-bottom: 0;"><a href="http://beian.miit.gov.cn/">京ICP备2023022073号-1</a></p>
        <p style="display: inline-flex; align-items: center;"><img style="height:20px;margin-right: 0.5rem;" src="/img/police.png" alt="police" height="20"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802044104">京公网安备11010802044104号</a></p>
        <p>Copyright © 2024 - PRESENT Z不殊 Built with Docusaurus.</p>
            </div></div></div></footer></div>
</body>
</html>